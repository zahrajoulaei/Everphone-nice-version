{"ast":null,"code":"import * as React from 'react';\nimport { encodeQueryParams } from 'serialize-query-params';\nimport { getSSRSafeSearchString, useUpdateRefIfShallowNew } from './helpers';\nimport { useLocationContext } from './LocationProvider';\nimport { sharedMemoizedQueryParser } from './memoizedQueryParser';\nimport shallowEqual from './shallowEqual';\n/**\n * Helper to get the latest decoded values with smart caching.\n * Abstracted into its own function to allow re-use in a functional setter (#26)\n */\n\nfunction getLatestDecodedValues(location, paramConfigMap, paramConfigMapRef, parsedQueryRef, encodedValuesCacheRef, decodedValuesCacheRef) {\n  // check if we have a new param config\n  var hasNewParamConfigMap = !shallowEqual(paramConfigMapRef.current, paramConfigMap); // read in the parsed query\n\n  var parsedQuery = sharedMemoizedQueryParser(getSSRSafeSearchString(location) // get the latest location object\n  ); // check if new encoded values are around (new parsed query).\n  // can use triple equals since we already cache this value\n\n  var hasNewParsedQuery = parsedQueryRef.current !== parsedQuery; // if nothing has changed, use existing.. so long as we have existing.\n\n  if (!hasNewParsedQuery && !hasNewParamConfigMap && encodedValuesCacheRef.current !== undefined) {\n    return {\n      encodedValues: encodedValuesCacheRef.current,\n      decodedValues: decodedValuesCacheRef.current\n    };\n  }\n\n  var encodedValuesCache = encodedValuesCacheRef.current || {};\n  var decodedValuesCache = decodedValuesCacheRef.current || {};\n  var encodedValues = {}; // we have new encoded values, so let's get new decoded values.\n  // recompute new values but only for those that changed\n\n  var paramNames = Object.keys(paramConfigMap);\n  var decodedValues = {};\n\n  for (var _i = 0, paramNames_1 = paramNames; _i < paramNames_1.length; _i++) {\n    var paramName = paramNames_1[_i]; // do we have a new encoded value?\n\n    var paramConfig = paramConfigMap[paramName];\n    var hasNewEncodedValue = !shallowEqual(encodedValuesCache[paramName], parsedQuery[paramName]); // if we have a new encoded value, re-decode. otherwise reuse cache\n\n    var encodedValue = void 0;\n    var decodedValue = void 0;\n\n    if (hasNewEncodedValue || encodedValuesCache[paramName] === undefined && decodedValuesCache[paramName] === undefined) {\n      encodedValue = parsedQuery[paramName];\n      decodedValue = paramConfig.decode(encodedValue);\n    } else {\n      encodedValue = encodedValuesCache[paramName];\n      decodedValue = decodedValuesCache[paramName];\n    }\n\n    encodedValues[paramName] = encodedValue;\n    decodedValues[paramName] = decodedValue;\n  } // keep referential equality for decoded valus if we didn't actually change anything\n\n\n  var hasNewDecodedValues = !shallowEqual(decodedValuesCacheRef.current, decodedValues, paramConfigMap);\n  return {\n    encodedValues: encodedValues,\n    decodedValues: hasNewDecodedValues ? decodedValues : decodedValuesCacheRef.current\n  };\n}\n/**\n * Given a query parameter configuration (mapping query param name to { encode, decode }),\n * return an object with the decoded values and a setter for updating them.\n */\n\n\nexport var useQueryParams = function (paramConfigMap) {\n  var _a = useLocationContext(),\n      location = _a.location,\n      getLocation = _a.getLocation,\n      setLocation = _a.setLocation; // read in the raw query\n\n\n  var parsedQuery = sharedMemoizedQueryParser(getSSRSafeSearchString(location)); // make caches\n\n  var paramConfigMapRef = React.useRef(paramConfigMap);\n  var parsedQueryRef = React.useRef(parsedQuery);\n  var encodedValuesCacheRef = React.useRef(undefined); // undefined for initial check\n\n  var decodedValuesCacheRef = React.useRef({}); // memoize paramConfigMap to make the API nicer for consumers.\n  // otherwise we'd have to useQueryParams(useMemo(() => { foo: NumberParam }, []))\n\n  paramConfigMap = shallowEqual(paramConfigMap, paramConfigMapRef.current) ? paramConfigMapRef.current : paramConfigMap; // decode all the values if we have changes\n\n  var _b = getLatestDecodedValues(location, paramConfigMap, paramConfigMapRef, parsedQueryRef, encodedValuesCacheRef, decodedValuesCacheRef),\n      encodedValues = _b.encodedValues,\n      decodedValues = _b.decodedValues; // update cached values in useEffects\n\n\n  useUpdateRefIfShallowNew(parsedQueryRef, parsedQuery);\n  useUpdateRefIfShallowNew(paramConfigMapRef, paramConfigMap);\n  useUpdateRefIfShallowNew(encodedValuesCacheRef, encodedValues);\n  useUpdateRefIfShallowNew(decodedValuesCacheRef, decodedValues, function (a, b) {\n    return shallowEqual(a, b, paramConfigMap);\n  }); // create a setter for updating multiple query params at once\n\n  var setQueryDeps = {\n    paramConfigMap: paramConfigMap,\n    setLocation: setLocation,\n    getLocation: getLocation\n  };\n  var setQueryDepsRef = React.useRef(setQueryDeps);\n  setQueryDepsRef.current = setQueryDeps;\n  var setQuery = React.useCallback(function (changes, updateType) {\n    var deps = setQueryDepsRef.current;\n    var encodedChanges;\n\n    if (typeof changes === 'function') {\n      // get latest decoded value to pass as a fresh arg to the setter fn\n      var latestValues = getLatestDecodedValues(deps.getLocation(), deps.paramConfigMap, paramConfigMapRef, parsedQueryRef, encodedValuesCacheRef, decodedValuesCacheRef).decodedValues;\n      decodedValuesCacheRef.current = latestValues; // keep cache in sync\n\n      encodedChanges = encodeQueryParams(deps.paramConfigMap, changes(latestValues));\n    } else {\n      // encode as strings for the URL\n      encodedChanges = encodeQueryParams(deps.paramConfigMap, changes);\n    } // update the URL\n\n\n    deps.setLocation(encodedChanges, updateType);\n  }, []); // no longer Partial\n\n  return [decodedValues, setQuery];\n};\nexport default useQueryParams;","map":{"version":3,"sources":["/Users/zahrajou/Desktop/Ever-service/node_modules/use-query-params/esm/useQueryParams.js"],"names":["React","encodeQueryParams","getSSRSafeSearchString","useUpdateRefIfShallowNew","useLocationContext","sharedMemoizedQueryParser","shallowEqual","getLatestDecodedValues","location","paramConfigMap","paramConfigMapRef","parsedQueryRef","encodedValuesCacheRef","decodedValuesCacheRef","hasNewParamConfigMap","current","parsedQuery","hasNewParsedQuery","undefined","encodedValues","decodedValues","encodedValuesCache","decodedValuesCache","paramNames","Object","keys","_i","paramNames_1","length","paramName","paramConfig","hasNewEncodedValue","encodedValue","decodedValue","decode","hasNewDecodedValues","useQueryParams","_a","getLocation","setLocation","useRef","_b","a","b","setQueryDeps","setQueryDepsRef","setQuery","useCallback","changes","updateType","deps","encodedChanges","latestValues"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { encodeQueryParams, } from 'serialize-query-params';\nimport { getSSRSafeSearchString, useUpdateRefIfShallowNew } from './helpers';\nimport { useLocationContext } from './LocationProvider';\nimport { sharedMemoizedQueryParser } from './memoizedQueryParser';\nimport shallowEqual from './shallowEqual';\n/**\n * Helper to get the latest decoded values with smart caching.\n * Abstracted into its own function to allow re-use in a functional setter (#26)\n */\nfunction getLatestDecodedValues(location, paramConfigMap, paramConfigMapRef, parsedQueryRef, encodedValuesCacheRef, decodedValuesCacheRef) {\n    // check if we have a new param config\n    var hasNewParamConfigMap = !shallowEqual(paramConfigMapRef.current, paramConfigMap);\n    // read in the parsed query\n    var parsedQuery = sharedMemoizedQueryParser(getSSRSafeSearchString(location) // get the latest location object\n    );\n    // check if new encoded values are around (new parsed query).\n    // can use triple equals since we already cache this value\n    var hasNewParsedQuery = parsedQueryRef.current !== parsedQuery;\n    // if nothing has changed, use existing.. so long as we have existing.\n    if (!hasNewParsedQuery &&\n        !hasNewParamConfigMap &&\n        encodedValuesCacheRef.current !== undefined) {\n        return {\n            encodedValues: encodedValuesCacheRef.current,\n            decodedValues: decodedValuesCacheRef.current,\n        };\n    }\n    var encodedValuesCache = encodedValuesCacheRef.current || {};\n    var decodedValuesCache = decodedValuesCacheRef.current || {};\n    var encodedValues = {};\n    // we have new encoded values, so let's get new decoded values.\n    // recompute new values but only for those that changed\n    var paramNames = Object.keys(paramConfigMap);\n    var decodedValues = {};\n    for (var _i = 0, paramNames_1 = paramNames; _i < paramNames_1.length; _i++) {\n        var paramName = paramNames_1[_i];\n        // do we have a new encoded value?\n        var paramConfig = paramConfigMap[paramName];\n        var hasNewEncodedValue = !shallowEqual(encodedValuesCache[paramName], parsedQuery[paramName]);\n        // if we have a new encoded value, re-decode. otherwise reuse cache\n        var encodedValue = void 0;\n        var decodedValue = void 0;\n        if (hasNewEncodedValue ||\n            (encodedValuesCache[paramName] === undefined &&\n                decodedValuesCache[paramName] === undefined)) {\n            encodedValue = parsedQuery[paramName];\n            decodedValue = paramConfig.decode(encodedValue);\n        }\n        else {\n            encodedValue = encodedValuesCache[paramName];\n            decodedValue = decodedValuesCache[paramName];\n        }\n        encodedValues[paramName] = encodedValue;\n        decodedValues[paramName] = decodedValue;\n    }\n    // keep referential equality for decoded valus if we didn't actually change anything\n    var hasNewDecodedValues = !shallowEqual(decodedValuesCacheRef.current, decodedValues, paramConfigMap);\n    return {\n        encodedValues: encodedValues,\n        decodedValues: hasNewDecodedValues\n            ? decodedValues\n            : decodedValuesCacheRef.current,\n    };\n}\n/**\n * Given a query parameter configuration (mapping query param name to { encode, decode }),\n * return an object with the decoded values and a setter for updating them.\n */\nexport var useQueryParams = function (paramConfigMap) {\n    var _a = useLocationContext(), location = _a.location, getLocation = _a.getLocation, setLocation = _a.setLocation;\n    // read in the raw query\n    var parsedQuery = sharedMemoizedQueryParser(getSSRSafeSearchString(location));\n    // make caches\n    var paramConfigMapRef = React.useRef(paramConfigMap);\n    var parsedQueryRef = React.useRef(parsedQuery);\n    var encodedValuesCacheRef = React.useRef(undefined); // undefined for initial check\n    var decodedValuesCacheRef = React.useRef({});\n    // memoize paramConfigMap to make the API nicer for consumers.\n    // otherwise we'd have to useQueryParams(useMemo(() => { foo: NumberParam }, []))\n    paramConfigMap = shallowEqual(paramConfigMap, paramConfigMapRef.current)\n        ? paramConfigMapRef.current\n        : paramConfigMap;\n    // decode all the values if we have changes\n    var _b = getLatestDecodedValues(location, paramConfigMap, paramConfigMapRef, parsedQueryRef, encodedValuesCacheRef, decodedValuesCacheRef), encodedValues = _b.encodedValues, decodedValues = _b.decodedValues;\n    // update cached values in useEffects\n    useUpdateRefIfShallowNew(parsedQueryRef, parsedQuery);\n    useUpdateRefIfShallowNew(paramConfigMapRef, paramConfigMap);\n    useUpdateRefIfShallowNew(encodedValuesCacheRef, encodedValues);\n    useUpdateRefIfShallowNew(decodedValuesCacheRef, decodedValues, function (a, b) {\n        return shallowEqual(a, b, paramConfigMap);\n    });\n    // create a setter for updating multiple query params at once\n    var setQueryDeps = {\n        paramConfigMap: paramConfigMap,\n        setLocation: setLocation,\n        getLocation: getLocation,\n    };\n    var setQueryDepsRef = React.useRef(setQueryDeps);\n    setQueryDepsRef.current = setQueryDeps;\n    var setQuery = React.useCallback(function (changes, updateType) {\n        var deps = setQueryDepsRef.current;\n        var encodedChanges;\n        if (typeof changes === 'function') {\n            // get latest decoded value to pass as a fresh arg to the setter fn\n            var latestValues = getLatestDecodedValues(deps.getLocation(), deps.paramConfigMap, paramConfigMapRef, parsedQueryRef, encodedValuesCacheRef, decodedValuesCacheRef).decodedValues;\n            decodedValuesCacheRef.current = latestValues; // keep cache in sync\n            encodedChanges = encodeQueryParams(deps.paramConfigMap, changes(latestValues));\n        }\n        else {\n            // encode as strings for the URL\n            encodedChanges = encodeQueryParams(deps.paramConfigMap, changes);\n        }\n        // update the URL\n        deps.setLocation(encodedChanges, updateType);\n    }, []);\n    // no longer Partial\n    return [decodedValues, setQuery];\n};\nexport default useQueryParams;\n"]},"metadata":{},"sourceType":"module"}