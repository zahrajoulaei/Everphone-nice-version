{"ast":null,"code":"import * as React from 'react';\nimport { StringParam } from 'serialize-query-params';\nimport { getSSRSafeSearchString, useUpdateRefIfShallowNew } from './helpers';\nimport { useLocationContext } from './LocationProvider';\nimport { sharedMemoizedQueryParser } from './memoizedQueryParser';\nimport shallowEqual from './shallowEqual';\n/**\n * Helper to get the latest decoded value with smart caching.\n * Abstracted into its own function to allow re-use in a functional setter (#26)\n */\n\nfunction getLatestDecodedValue(location, name, paramConfig, paramConfigRef, encodedValueCacheRef, decodedValueCacheRef) {\n  var _a; // check if we have a new param config\n\n\n  var hasNewParamConfig = !shallowEqual(paramConfigRef.current, paramConfig);\n  var isValueEqual = (_a = paramConfig.equals) !== null && _a !== void 0 ? _a : shallowEqual; // read in the parsed query\n\n  var parsedQuery = sharedMemoizedQueryParser(getSSRSafeSearchString(location) // get the latest location object\n  ); // read in the encoded string value (we have to check cache if available because\n  // sometimes the query string changes so we get a new parsedQuery but this value\n  // didn't change, so we should avoid generating a new array or whatever value)\n\n  var hasNewEncodedValue = !shallowEqual(encodedValueCacheRef.current, parsedQuery[name]);\n  var encodedValue = hasNewEncodedValue ? parsedQuery[name] : encodedValueCacheRef.current; // only decode if we have changes to encoded value or the config.\n  // check for undefined to handle initial case\n\n  if (!hasNewEncodedValue && !hasNewParamConfig && decodedValueCacheRef.current !== undefined) {\n    return decodedValueCacheRef.current;\n  }\n\n  var newDecodedValue = paramConfig.decode(encodedValue);\n  var hasNewDecodedValue = (decodedValueCacheRef.current == null || newDecodedValue == null) && decodedValueCacheRef.current === newDecodedValue || !isValueEqual(decodedValueCacheRef.current, newDecodedValue); // if we have a new decoded value use it, otherwise use cached\n\n  return hasNewDecodedValue ? newDecodedValue : decodedValueCacheRef.current;\n}\n/**\n * Given a query param name and query parameter configuration ({ encode, decode })\n * return the decoded value and a setter for updating it.\n *\n * The setter takes two arguments (newValue, updateType) where updateType\n * is one of 'replace' | 'replaceIn' | 'push' | 'pushIn', defaulting to\n * 'pushIn'.\n *\n * You may optionally pass in a rawQuery object, otherwise the query is derived\n * from the location available in the context.\n *\n * D = decoded type\n * D2 = return value from decode (typically same as D)\n */\n\n\nexport var useQueryParam = function (name, paramConfig) {\n  if (paramConfig === void 0) {\n    paramConfig = StringParam;\n  }\n\n  var _a = useLocationContext(),\n      location = _a.location,\n      getLocation = _a.getLocation,\n      setLocation = _a.setLocation; // read in the raw query\n\n\n  var parsedQuery = sharedMemoizedQueryParser(getSSRSafeSearchString(location)); // make caches\n\n  var encodedValueCacheRef = React.useRef();\n  var paramConfigRef = React.useRef(paramConfig);\n  var decodedValueCacheRef = React.useRef();\n  var decodedValue = getLatestDecodedValue(location, name, paramConfig, paramConfigRef, encodedValueCacheRef, decodedValueCacheRef); // update cached values in a useEffect\n\n  useUpdateRefIfShallowNew(encodedValueCacheRef, parsedQuery[name]);\n  useUpdateRefIfShallowNew(paramConfigRef, paramConfig);\n  useUpdateRefIfShallowNew(decodedValueCacheRef, decodedValue, paramConfig.equals); // create the setter, memoizing via useCallback\n\n  var setValueDeps = {\n    paramConfig: paramConfig,\n    name: name,\n    setLocation: setLocation,\n    getLocation: getLocation\n  };\n  var setValueDepsRef = React.useRef(setValueDeps);\n  setValueDepsRef.current = setValueDeps;\n  var setValue = React.useCallback(function setValueCallback(newValue, updateType) {\n    var _a;\n\n    var deps = setValueDepsRef.current;\n    var newEncodedValue; // allow functional updates #26\n\n    if (typeof newValue === 'function') {\n      // get latest decoded value to pass as a fresh arg to the setter fn\n      var latestValue = getLatestDecodedValue(deps.getLocation(), deps.name, deps.paramConfig, paramConfigRef, encodedValueCacheRef, decodedValueCacheRef);\n      decodedValueCacheRef.current = latestValue; // keep cache in sync\n\n      newEncodedValue = deps.paramConfig.encode(newValue(latestValue));\n    } else {\n      newEncodedValue = deps.paramConfig.encode(newValue);\n    } // update the URL\n\n\n    deps.setLocation((_a = {}, _a[deps.name] = newEncodedValue, _a), updateType);\n  }, []);\n  return [decodedValue, setValue];\n};","map":{"version":3,"sources":["/Users/zahrajou/Desktop/Ever-service/node_modules/use-query-params/esm/useQueryParam.js"],"names":["React","StringParam","getSSRSafeSearchString","useUpdateRefIfShallowNew","useLocationContext","sharedMemoizedQueryParser","shallowEqual","getLatestDecodedValue","location","name","paramConfig","paramConfigRef","encodedValueCacheRef","decodedValueCacheRef","_a","hasNewParamConfig","current","isValueEqual","equals","parsedQuery","hasNewEncodedValue","encodedValue","undefined","newDecodedValue","decode","hasNewDecodedValue","useQueryParam","getLocation","setLocation","useRef","decodedValue","setValueDeps","setValueDepsRef","setValue","useCallback","setValueCallback","newValue","updateType","deps","newEncodedValue","latestValue","encode"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { StringParam } from 'serialize-query-params';\nimport { getSSRSafeSearchString, useUpdateRefIfShallowNew } from './helpers';\nimport { useLocationContext } from './LocationProvider';\nimport { sharedMemoizedQueryParser } from './memoizedQueryParser';\nimport shallowEqual from './shallowEqual';\n/**\n * Helper to get the latest decoded value with smart caching.\n * Abstracted into its own function to allow re-use in a functional setter (#26)\n */\nfunction getLatestDecodedValue(location, name, paramConfig, paramConfigRef, encodedValueCacheRef, decodedValueCacheRef) {\n    var _a;\n    // check if we have a new param config\n    var hasNewParamConfig = !shallowEqual(paramConfigRef.current, paramConfig);\n    var isValueEqual = (_a = paramConfig.equals) !== null && _a !== void 0 ? _a : shallowEqual;\n    // read in the parsed query\n    var parsedQuery = sharedMemoizedQueryParser(getSSRSafeSearchString(location) // get the latest location object\n    );\n    // read in the encoded string value (we have to check cache if available because\n    // sometimes the query string changes so we get a new parsedQuery but this value\n    // didn't change, so we should avoid generating a new array or whatever value)\n    var hasNewEncodedValue = !shallowEqual(encodedValueCacheRef.current, parsedQuery[name]);\n    var encodedValue = hasNewEncodedValue\n        ? parsedQuery[name]\n        : encodedValueCacheRef.current;\n    // only decode if we have changes to encoded value or the config.\n    // check for undefined to handle initial case\n    if (!hasNewEncodedValue &&\n        !hasNewParamConfig &&\n        decodedValueCacheRef.current !== undefined) {\n        return decodedValueCacheRef.current;\n    }\n    var newDecodedValue = paramConfig.decode(encodedValue);\n    var hasNewDecodedValue = ((decodedValueCacheRef.current == null || newDecodedValue == null) &&\n        decodedValueCacheRef.current === newDecodedValue) ||\n        !isValueEqual(decodedValueCacheRef.current, newDecodedValue);\n    // if we have a new decoded value use it, otherwise use cached\n    return hasNewDecodedValue\n        ? newDecodedValue\n        : decodedValueCacheRef.current;\n}\n/**\n * Given a query param name and query parameter configuration ({ encode, decode })\n * return the decoded value and a setter for updating it.\n *\n * The setter takes two arguments (newValue, updateType) where updateType\n * is one of 'replace' | 'replaceIn' | 'push' | 'pushIn', defaulting to\n * 'pushIn'.\n *\n * You may optionally pass in a rawQuery object, otherwise the query is derived\n * from the location available in the context.\n *\n * D = decoded type\n * D2 = return value from decode (typically same as D)\n */\nexport var useQueryParam = function (name, paramConfig) {\n    if (paramConfig === void 0) { paramConfig = StringParam; }\n    var _a = useLocationContext(), location = _a.location, getLocation = _a.getLocation, setLocation = _a.setLocation;\n    // read in the raw query\n    var parsedQuery = sharedMemoizedQueryParser(getSSRSafeSearchString(location));\n    // make caches\n    var encodedValueCacheRef = React.useRef();\n    var paramConfigRef = React.useRef(paramConfig);\n    var decodedValueCacheRef = React.useRef();\n    var decodedValue = getLatestDecodedValue(location, name, paramConfig, paramConfigRef, encodedValueCacheRef, decodedValueCacheRef);\n    // update cached values in a useEffect\n    useUpdateRefIfShallowNew(encodedValueCacheRef, parsedQuery[name]);\n    useUpdateRefIfShallowNew(paramConfigRef, paramConfig);\n    useUpdateRefIfShallowNew(decodedValueCacheRef, decodedValue, paramConfig.equals);\n    // create the setter, memoizing via useCallback\n    var setValueDeps = {\n        paramConfig: paramConfig,\n        name: name,\n        setLocation: setLocation,\n        getLocation: getLocation,\n    };\n    var setValueDepsRef = React.useRef(setValueDeps);\n    setValueDepsRef.current = setValueDeps;\n    var setValue = React.useCallback(function setValueCallback(newValue, updateType) {\n        var _a;\n        var deps = setValueDepsRef.current;\n        var newEncodedValue;\n        // allow functional updates #26\n        if (typeof newValue === 'function') {\n            // get latest decoded value to pass as a fresh arg to the setter fn\n            var latestValue = getLatestDecodedValue(deps.getLocation(), deps.name, deps.paramConfig, paramConfigRef, encodedValueCacheRef, decodedValueCacheRef);\n            decodedValueCacheRef.current = latestValue; // keep cache in sync\n            newEncodedValue = deps.paramConfig.encode(newValue(latestValue));\n        }\n        else {\n            newEncodedValue = deps.paramConfig.encode(newValue);\n        }\n        // update the URL\n        deps.setLocation((_a = {}, _a[deps.name] = newEncodedValue, _a), updateType);\n    }, []);\n    return [decodedValue, setValue];\n};\n"]},"metadata":{},"sourceType":"module"}